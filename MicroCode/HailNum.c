//冰雹数

//任意给定一个正整数N， 
//如果是偶数，执行： N / 2
//如果是奇数，执行： N * 3 + 1

//生成的新的数字再执行同样的动作，循环往复。

//通过观察发现，这个数字会一会儿上升到很高， 
//一会儿又降落下来。 
//就这样起起落落的，但最终必会落到“1” 
//这有点像小冰雹粒子在冰雹云中翻滚增长的样子。

//比如N = 9
//9,28,14,7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1
//可以看到，N = 9的时候，这个“小冰雹”最高冲到了52这个高度。

//输入格式： 
//一个正整数N（N < 1000000） 
//输出格式： 
//一个正整数，表示不大于N的数字，经过冰雹数变换过程中，最高冲到了多少。

//例如，输入： 
//10
//程序应该输出： 
//52

//再例如，输入： 
//100
//程序应该输出： 
//9232

//输入1000000
//输出56991483520

//资源约定： 
//峰值内存消耗 < 256M
//CPU消耗 < 1000ms

//请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。

//所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。

//注意: main函数需要返回0
//注意: 只使用ANSI C/ ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。 
//注意: 所有依赖的函数必须明确地在源文件中 #include ， 不能通过工程设置而省略常用头文件。

//提交时，注意选择所期望的编译器类型。
#include <stdio.h>
#include <stdint.h>

int main(void)
{
	uint64_t num = 0, max = 0, hail = 0, curNum = 0;

	//冰雹数的表和冰雹数标准表,如果一个数算过了,则标志位为1
	uint64_t tab[500000] = { 0 };
	fscanf_s(stdin, "%d", &num);

	//只计算奇数,如果是偶数,按照规则是除以2,则肯定已经计算过了
	for (curNum = 1;curNum < num; curNum += 2)
	{
		//如果这个数已经算过了则跳过
		if (tab[curNum/2] == 1)
			continue;
		//奇数乘3加1,将这个结果和表中的比较,保存较大的数,如果hail落到比i小,说明已经算过了,停止计算
		for (hail = curNum; ;)
		{
			//i的冰雹数途中出现的所有数的冰雹数结果和i相等,因此标记该数为计算过,flag = 1
			if (hail % 2 == 1 && hail < 1000000)
			{
				tab[hail/2] = 1;
			}
			hail = hail * 3 + 1;
			//计算后如果发现它向上冲了,则更新表
			if (hail > tab[curNum/2])
			{
				tab[curNum/2] = hail;
			}
			//循环直到冰雹数变成奇数
			for (;(hail /= 2) % 2 == 0;)
				;
			//如果落到已经算过的数的范围内,则退出循环
			if (hail <= curNum)
				break;
		}
		max = max >= tab[curNum/2] ? max : tab[curNum/2];
	}

	fprintf(stdout, "%I64u\n", max);
	system("pause");
	return 0;
}